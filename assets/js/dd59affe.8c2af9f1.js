"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[331],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||a;return n?i.createElement(h,o(o({ref:t},c),{},{components:n})):i.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var u=2;u<a;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},928:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var i=n(7462),r=(n(7294),n(3905));const a={book:"Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems - Martin Kleppman"},o=void 0,s={unversionedId:"learn-in-public/Engineering/Distributed Systems/Distributed Computing",id:"learn-in-public/Engineering/Distributed Systems/Distributed Computing",title:"Distributed Computing",description:"distributedsystems #distributed",source:"@site/docs/learn-in-public/1. Engineering/Distributed Systems/Distributed Computing.md",sourceDirName:"learn-in-public/1. Engineering/Distributed Systems",slug:"/learn-in-public/Engineering/Distributed Systems/Distributed Computing",permalink:"/docs/learn-in-public/Engineering/Distributed Systems/Distributed Computing",draft:!1,tags:[],version:"current",frontMatter:{book:"Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems - Martin Kleppman"},sidebar:"learn-in-public",previous:{title:"Consensus",permalink:"/docs/learn-in-public/Engineering/Distributed Systems/Consensus"},next:{title:"Lamport Timestamps",permalink:"/docs/learn-in-public/Engineering/Distributed Systems/Lamport Timestamps"}},l={},u=[],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"#distributedenvironments #distributedsystems #distributed\n#clocks #network #failure"),(0,r.kt)("p",null,"What happens when everything goes wrong? what if only #partialfailures happens?"),(0,r.kt)("p",null,"The real problems roses only, when partial failures happens, because they introduce nondeterministic operations to the environment which might cause inconsistencies and unpredictable results."),(0,r.kt)("p",null,"There are two main types of computing environment."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"#supercomputers"),(0,r.kt)("li",{parentName:"ul"},"#cloudscomputing")),(0,r.kt)("p",null,"Super computers always prefer to escalate partial failure to total failure, thus keeping consistency.\nPartial failure its a real deal on cloud computing by which we depend upon side effects on network and real life."),(0,r.kt)("p",null,"The usual way to handle the possibility of an receiver not receiving or responding from a request is a ",(0,r.kt)("em",{parentName:"p"},"timeout"),".\nBut for how long?"),(0,r.kt)("p",null,"Premature timeouts: if you declare a node dead prematurely, you can overload the entire cluster. If there only too much overload causing a delay in the response time, killing nodes may even increase it further."),(0,r.kt)("p",null,"Late timeouts: can cause an horrifying experience for the end-user and a performance hit."),(0,r.kt)("p",null,"For enterprise application on cloud enviroments, you need to decide the timeout experimentally. Monitoring it and taking into account the context of the application logic. Even so, dynamically changing it with metrics.\nSuggestions : Phi Accrucal failure detector."),(0,r.kt)("p",null,"#clocks"),(0,r.kt)("p",null,"we can separate the usage of clocks and time on software on two categories:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"points in time"),(0,r.kt)("li",{parentName:"ul"},"duration/measure")),(0,r.kt)("p",null,"The time comes always from the hardware, which may not be synchronized perfectly.\n#time-of-day clocks are not usefol for measuring elapsed time, since there can be differenteces between hardwares, even thou they are on NTP. This is a job for #monoticclocks"),(0,r.kt)("p",null,"if your software requires high precision for time of day and synchronized clocks, you need to ensure the offset of all nodes, if one drifts way too much, declare it dead."),(0,r.kt)("p",null,"One clear example is syncrhonization of data on replicas, with #lastwritewins #lww. which depends on the timestamp from the change.."),(0,r.kt)("p",null,"Databases such as Spanner, utilize the timestamp to generate a transaction id for Snapshop isolation. Since generating transaciton id on distributed databases can be conflicting."),(0,r.kt)("p",null,"#clocks #GC #RTOS"),(0,r.kt)("p",null,"#processpauses"),(0,r.kt)("p",null,"Another critical and dangerous usage of clocks, is to lock processes depending on timestamps(ex: timeouts)"),(0,r.kt)("p",null,"Partitions with single leaders often use ",(0,r.kt)("em",{parentName:"p"},"lease")," . Each time an leader is elected, it gets a ",(0,r.kt)("em",{parentName:"p"},"lease")," which has an expiration time. Before expiring, the leader has to renew the #lease."),(0,r.kt)("p",null,"On example, using single leader, is that the time to renew can be overlapped by a GC-looop, container pausing/resuming, heavy IO, disk swap, physical closing of laptop lid or even a UNIX process SIGSTOP."),(0,r.kt)("p",null,"Preventing GC : the runtime can actually notify that the node will go through GC and routing any traffic to other instance. Or simply kill the node and restart before long-lived object GC."),(0,r.kt)("p",null,"One way to prevent leases and corruption of date, when writing with single leader. is to add fencing tokens to lease."),(0,r.kt)("p",null,"Whenever we claim a lease, we also add an token(that could be incremented or whatever) so we check if the current writing node has the valid token"),(0,r.kt)("p",null,"Tip: if you use zookeper for locking service, either the zxid(trnsaction id) or the node version (cversion) can be used as fencing token."),(0,r.kt)("p",null,"Whenever we are modeling a system, we should categorize them an assume what can and cannot happen so we can write our algorithms."),(0,r.kt)("p",null,"We can category the models as(timing):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"synchronous, were everything is as expected"),(0,r.kt)("li",{parentName:"ul"},"partially synchronous, were most of the time it is."),(0,r.kt)("li",{parentName:"ul"},"asynchronous, were the algo cannot make any assumption about timing")),(0,r.kt)("p",null,"And regarding fault-tolerance, we can categorize it as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"crash-stop faults, where the system stops 100% and restarts."),(0,r.kt)("li",{parentName:"ul"},"crash-recovery faults, where we assume the data lost can be retried. (it is persisted somwhow)"),(0,r.kt)("li",{parentName:"ul"},"nodes can even deceive our internal systems.")),(0,r.kt)("p",null,"Algorithms must have an correctness based on some properties, that can be #liveness properties or #safety. such as uniqueness, #monotonicsequence, #availability"),(0,r.kt)("p",null,"To map real world to system model we need to make assumptions, and even handle edge cases that were never meant to happen, requiring human work."))}d.isMDXComponent=!0}}]);